DART FULL DOCUMENTATION NOTES (EXPANDED)

This file contains an expanded explanation of Dart concepts. Each
section has detailed descriptions, tips, and real-life analogies.

------------------------------------------------------------
1. VARIABLES AND TYPES
------------------------------------------------------------
Variables in Dart are like containers for values. Each container has
rules on what it can store and how many times it can be changed.

ðŸ”¹ var
- A variable whose type is inferred by Dart at the time of assignment.
- Example: var age = 21; Dart knows 'age' is an int.
- Once assigned, its type cannot be changed. So age = "twenty" is invalid.

ðŸ”¹ final
- A variable that can be set only once. It is like writing your name
on a permanent marker. Once written, it stays.
- Example: final city = "Manila"; you cannot reassign city later.

ðŸ”¹ const
- A compile-time constant. The value must be known before running
the program.
- Example: const pi = 3.14;
- You cannot assign DateTime.now() to const because it is not known
at compile time.

ðŸ”¹ late
- Declares a variable that will be initialized later but before use.
- Example: late String message; message = "Hello!";
- Useful for expensive operations or when you want to assign values
in constructors.

ðŸ”¹ dynamic
- Can hold any type of value, like a shapeshifting box.
- Example: dynamic x = 10; x = "Hello"; x = true;
- Not recommended often because it removes type safety.

ðŸ”¹ Nullable types (?)
- By default, Dart variables are non-nullable. If you want them
to accept null, use '?'.
- Example: String? name; name = null;

------------------------------------------------------------
2. CONTROL FLOW
------------------------------------------------------------
Control flow is how Dart decides which path to take in your program.

ðŸ”¹ if/else
- Basic conditional branching.
- Example: if (age > 18) print("Adult"); else print("Minor");

ðŸ”¹ switch/case
- Used when you have multiple possible values for a variable.
- Example:
switch (grade) {
  case "A": print("Excellent");
  break;
  case "B": print("Good");
  break;
  default: print("Try harder");
}

ðŸ”¹ for loop
- Traditional loop with a counter.
- Example: for (int i = 0; i < 5; i++) print(i);

ðŸ”¹ for-in loop
- Iterates over collections.
- Example: for (var item in list) print(item);

ðŸ”¹ while loop
- Runs as long as condition is true.
- Example: while (x < 10) { x++; }

ðŸ”¹ do-while
- Executes at least once.
- Example: do { print("Run"); } while(false);

------------------------------------------------------------
3. FUNCTIONS
------------------------------------------------------------
Functions are reusable blocks of code. Dart functions can be simple
or advanced.

ðŸ”¹ void function
- Does not return anything.
- Example: void greet() { print("Hello!"); }

ðŸ”¹ return type function
- Specifies the return type.
- Example: int add(int a, int b) { return a + b; }

ðŸ”¹ optional positional parameters
- Enclosed in [].
- Example: void greet([String name = "User"]) { print("Hello $name"); }

ðŸ”¹ named parameters
- Enclosed in {}.
- Example: void greet({String name = "User"}) { print("Hello $name"); }

ðŸ”¹ arrow functions
- Shorthand for functions with a single expression.
- Example: int square(int x) => x * x;

ðŸ”¹ higher-order functions
- Accept functions as arguments or return functions.
- Example: list.forEach((item) => print(item));

------------------------------------------------------------
4. OOP (CLASSES, OBJECTS, INHERITANCE)
------------------------------------------------------------
Dart supports full Object-Oriented Programming (OOP).

ðŸ”¹ class
- Blueprint for objects.
- Example: class Person { String name; Person(this.name); }

ðŸ”¹ constructor
- Special method to initialize objects.
- Example: Person(this.name);

ðŸ”¹ named constructors
- Provide multiple ways to create objects.
- Example: Car.old(this.brand) : year = 1990;

ðŸ”¹ super
- Calls the parent class constructor or method.
- Example: class Dog extends Animal { Dog(String name) : super(name); }

ðŸ”¹ super() : props
- Initializes parent properties before the child constructor runs.

ðŸ”¹ polymorphism
- Different classes implement the same method differently.
- Example: Cat and Dog both override speak() differently.

ðŸ”¹ abstract class
- Cannot be instantiated. Defines contracts.
- Example: abstract class Shape { void draw(); }

ðŸ”¹ interface (implements)
- Forces a class to implement all methods of another class.
- Example: class Human implements Walker { @override void walk() {} }

ðŸ”¹ mixin (with)
- Reuse code in multiple classes without inheritance.
- Example: mixin Fly { void fly() => print("Flying"); }

------------------------------------------------------------
5. COLLECTIONS
------------------------------------------------------------
Collections store groups of data.

ðŸ”¹ List
- Ordered collection, allows duplicates.
- Example: var nums = [1, 2, 3];

ðŸ”¹ Set
- Unordered collection, unique values only.
- Example: var unique = {1, 2, 3};

ðŸ”¹ Map
- Key-value pairs.
- Example: var person = {"name": "John", "age": 30};

ðŸ”¹ spread operator (...)
- Expands collections.
- Example: var nums = [1, 2, ...[3, 4]];

ðŸ”¹ null-aware spread (...?)
- Expands only if not null.

ðŸ”¹ collection if / for
- Build collections with conditions.
- Example: var list = [1, 2, if (addExtra) 3];

------------------------------------------------------------
6. ASYNC / AWAIT / FUTURES
------------------------------------------------------------
Dart is asynchronous by nature, using Futures.

ðŸ”¹ Future
- Represents a value that will come later.
- Example: Future<int> fetchData() async { return 42; }

ðŸ”¹ async
- Marks a function that has asynchronous code.

ðŸ”¹ await
- Waits for a Future to complete.

ðŸ”¹ then()
- Alternative to await.

ðŸ”¹ try/catch with async
- Handles errors gracefully.

ðŸ”¹ Streams
- For handling multiple values asynchronously.
- Example: Stream<int> counter() async* { yield 1; yield 2; }

------------------------------------------------------------
7. DART IO (FILES, DIRECTORY, HTTP, STDIN/STDOUT)
------------------------------------------------------------
The dart:io library provides file, directory, and network operations.

ðŸ”¹ File read/write
- File("data.txt").writeAsString("Hello");
- File("data.txt").readAsString();

ðŸ”¹ Directory
- Create, list, or delete folders.
- Example: Directory("demo").create();

ðŸ”¹ HttpServer
- Start a simple HTTP server.
- Example: HttpServer.bind("127.0.0.1", 8080);

ðŸ”¹ stdin/stdout
- Read user input and print output.
- stdout.write("Enter name: "); stdin.readLineSync();

------------------------------------------------------------
8. ADVANCED DART FEATURES
------------------------------------------------------------
Advanced tools make Dart powerful.

ðŸ”¹ const constructor
- Creates compile-time objects.
- Example: const Point(0, 0);

ðŸ”¹ enums
- Fixed set of values.
- Example: enum Color { red, green, blue }

ðŸ”¹ extension methods
- Add methods to existing types.
- Example: extension StringCap on String { String cap() => this[0].toUpperCase() + substring(1); }

ðŸ”¹ cascade operator (..)
- Perform multiple operations on same object.
- Example: person..name = "John"..age = 30..sayHello();

------------------------------------------------------------
9. MAIN FUNCTION
------------------------------------------------------------
The main entry point for Dart apps.

ðŸ”¹ main()
- Every Dart program starts here.
- Example: void main() { print("Hello Dart!"); }

ðŸ”¹ Future main
- Async programs can use Future<void> main() async {}

------------------------------------------------------------
EXTRA NOTES
------------------------------------------------------------
- Dart is strongly typed but flexible with var and dynamic.
- Use final for values that don't change, const for constants.
- Prefer async/await over then() for readability.
- OOP in Dart combines features of Java, C#, and more.
- The cascade operator (..) is unique and very powerful.
- Mixins allow composition over inheritance.
- dart:io makes Dart usable for backend and scripting.

End of Documentation.
